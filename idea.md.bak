# MCP Router Tool - Complete Requirements and Development Plan

## Original Requirements and Outline

### Project Description
I want to develop a tool in python that is a UX for adding and administering, as well as functioning as a router for MCP servers (https://gofastmcp.com/getting-started/welcome). The Model Context Protocol (MCP) is a new, standardized way to provide context and tools to your LLMs, and FastMCP makes building MCP servers and clients simple and intuitive. Create tools, expose resources, define prompts, and more with clean, Pythonic code.

The overall intuition of this tool is that it is a UX tool and service that allows you to add mcp servers via github url. The tool acts as an MCP server itself, and lists the added servers as tools. It loads the added MCP tools upon request in a containered environment and handles the IO between the LLM and tool.

### Core Requirements
1. Has a UX for adding and editing separate MCP servers.
2. New MCP servers can be added by github URL but supports npx, uvx, and docker.
3. Uses claude (https://github.com/anthropics/anthropic-sdk-python) to read github readme content (e.g. retrieved via requests), and define an install and serving plan.
4. Supports: sse, stdio, and streamable http forms of MCP
5. Can be connected to Claude Desktop locally, or can be deployed to serve an endpoint that can be added to Claude to access the router tools.
6. The library FastMCP at https://gofastmcp.com/getting-started/welcome is a well done implementation of MCP and could be used for support for specific requirements.
7. We launch the services when requested into a containered environment because we need to support typescript, python, and other environments.
8. The tool should supply a field, when adding a server, with any ENV variables with placeholders for keys that need to be added, based on what was parsed out of the github url. This will be used when the individual mcp tool is called.
9. We should have a default sandbox tool in python with main libraries like pandas, numpy, etc installed that can be used as a tool to send code to to get the result.

### Additional Context
- Container spawning: on-demand per request (with potential startup delays)
- Container persistence: fresh containers for each session
- Development timeline: 4 weeks, 1 developer, 1-week sprints
- Suggested library: https://github.com/vndee/llm-sandbox for npx, uvx, and docker sandboxes

### Code Standards
- Clean, accurate, readable, and efficient code
- Comprehensive docstrings for all functions and classes
- Proper error handling and logging
- Type hints on all function parameters and return values
- Centralized API functionality rather than repeating across files
- Rate limiting and retries for all API requests
- Do not cut corners or leave updates for later. If you start code, finish it.

### Implementation Rules
- DO NOT add unnecessary complexity or features not requested
- DO NOT over-engineer solutions; prefer simplicity
- Authentication should be discovered from OpenAPI spec when possible
- Only GET and POST requests are supported for API endpoints
- Proper documentation for all public APIs
- Proper unittests (with unittest) for all major functionality

---

## Complete Development Plan

### System Description
A Python-based MCP (Model Context Protocol) router that acts as a unified gateway for multiple MCP servers. The tool provides a web-based UI for managing MCP servers, automatically analyzes GitHub repositories using Claude to generate installation plans, and dynamically spawns containerized environments for each MCP server on-demand. The router itself functions as an MCP server, exposing all registered servers' tools through a single interface.

### Core Components
1. **Web UI** - Flask-based interface with server-side rendering for server management
2. **MCP Router** - FastMCP-based routing engine
3. **Container Manager** - llm-sandbox integration for multi-runtime support
4. **Claude Analyzer** - Automated repository analysis and setup
5. **Transport Bridge** - Multi-protocol support (stdio, SSE, HTTP)
6. **Configuration Manager** - Claude Desktop and deployment configs

## Technical Architecture

### System Architecture Diagram
```
┌─────────────────┐     ┌─────────────────┐     ┌─────────────────┐
│  Claude Desktop │     │   Web Browser   │     │  Claude.ai API  │
│   (Local Mode)  │     │   (Admin UI)    │     │  (Remote Mode)  │
└────────┬────────┘     └────────┬────────┘     └────────┬────────┘
         │                       │                        │
         │ stdio                 │ HTTP                  │ HTTP/SSE
         │                       │                        │
┌────────┴───────────────────────┴────────────────────────┴────────┐
│                        MCP Router Service                         │
│  ┌─────────────┐  ┌──────────────┐  ┌────────────────────────┐  │
│  │    Flask    │  │   FastMCP    │  │   Transport Manager    │  │
│  │  Web Server │  │   Router     │  │ (stdio/SSE/HTTP)       │  │
│  └─────────────┘  └──────────────┘  └────────────────────────┘  │
│  ┌─────────────┐  ┌──────────────┐  ┌────────────────────────┐  │
│  │   Claude    │  │   GitHub     │  │  Container Orchestrator │  │
│  │  Analyzer   │  │   Service    │  │   (llm-sandbox)        │  │
│  └─────────────┘  └──────────────┘  └────────────────────────┘  │
└───────────────────────────────────────────────────────────────────┘
                                │
         ┌──────────────────────┼──────────────────────┐
         │                      │                      │
┌────────▼────────┐   ┌─────────▼────────┐   ┌────────▼────────┐
│ NPX Container   │   │  UVX Container   │   │ Docker Container│
│ (Node.js MCP)   │   │  (Python MCP)    │   │  (Custom MCP)   │
└─────────────────┘   └──────────────────┘   └─────────────────┘
```

### Technology Stack

#### Backend (Single Flask Application)
- **Python 3.11+** - Core language
- **Flask 2.3+** - Web framework with Jinja2 templates
- **FastMCP** - MCP protocol implementation
- **llm-sandbox** - Container runtime management
- **anthropic-sdk-python** - Claude integration
- **SQLAlchemy + Flask-SQLAlchemy** - Database ORM
- **Flask-WTF** - Form handling and CSRF protection
- **Flask-Login** - Session management
- **Pydantic** - Data validation
- **httpx** - Async HTTP client
- **structlog** - Structured logging
- **pytest + pytest-asyncio** - Testing

#### Frontend (Server-Side Rendered)
- **Jinja2 Templates** - HTML templating engine
- **htmx** - Dynamic HTML updates without full page reloads
- **TailwindCSS** - Styling (via CDN, no build process)
- **Minimal JavaScript** - Progressive enhancement only

#### Infrastructure
- **Docker** - Containerization
- **Docker Compose** - Local development
- **E2B** - Cloud container runtime (optional)
- **Prometheus + Grafana** - Monitoring


## Database Schema

```sql
-- MCP Servers table
CREATE TABLE mcp_servers (
    id TEXT PRIMARY KEY DEFAULT (lower(hex(randomblob(16)))),
    name TEXT NOT NULL UNIQUE,
    display_name TEXT NOT NULL,
    github_url TEXT NOT NULL,
    description TEXT,
    runtime_type TEXT NOT NULL CHECK(runtime_type IN ('npx', 'uvx', 'docker')),
    install_command TEXT NOT NULL,
    start_command TEXT NOT NULL,
    transport_type TEXT NOT NULL CHECK(transport_type IN ('stdio', 'sse', 'http')),
    transport_config JSON NOT NULL,
    env_variables JSON NOT NULL DEFAULT '[]',
    capabilities JSON NOT NULL DEFAULT '{}',
    is_active BOOLEAN NOT NULL DEFAULT true,
    is_healthy BOOLEAN NOT NULL DEFAULT false,
    last_health_check TIMESTAMP,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- Environment Variables table (normalized)
CREATE TABLE env_variables (
    id TEXT PRIMARY KEY DEFAULT (lower(hex(randomblob(16)))),
    server_id TEXT NOT NULL,
    key TEXT NOT NULL,
    description TEXT,
    is_required BOOLEAN NOT NULL DEFAULT true,
    is_secret BOOLEAN NOT NULL DEFAULT false,
    default_value TEXT,
    validation_regex TEXT,
    FOREIGN KEY (server_id) REFERENCES mcp_servers(id) ON DELETE CASCADE,
    UNIQUE(server_id, key)
);

-- Audit Log table
CREATE TABLE audit_logs (
    id TEXT PRIMARY KEY DEFAULT (lower(hex(randomblob(16)))),
    timestamp TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    action TEXT NOT NULL,
    resource_type TEXT NOT NULL,
    resource_id TEXT,
    details JSON,
    user_id TEXT,
    ip_address TEXT
);

-- Container Sessions table
CREATE TABLE container_sessions (
    id TEXT PRIMARY KEY DEFAULT (lower(hex(randomblob(16)))),
    server_id TEXT NOT NULL,
    container_id TEXT NOT NULL,
    status TEXT NOT NULL CHECK(status IN ('starting', 'running', 'stopping', 'stopped', 'error')),
    started_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    stopped_at TIMESTAMP,
    metrics JSON,
    FOREIGN KEY (server_id) REFERENCES mcp_servers(id) ON DELETE CASCADE
);
```

## API Specification

### REST API Endpoints

```yaml
# Server Management
POST   /api/servers/analyze
  Request:
    github_url: string
  Response:
    name: string
    description: string
    runtime_type: 'npx' | 'uvx' | 'docker'
    install_command: string
    start_command: string
    env_variables: Array<{key: string, description: string, required: boolean}>
    detected_tools: Array<string>

POST   /api/servers
  Request:
    name: string
    github_url: string
    runtime_type: string
    install_command: string
    start_command: string
    transport_type: string
    transport_config: object
    env_variables: Array<EnvVariable>

GET    /api/servers
  Response:
    servers: Array<Server>

GET    /api/servers/{id}
  Response: Server

PUT    /api/servers/{id}
  Request: Partial<Server>
  Response: Server

DELETE /api/servers/{id}
  Response: {success: boolean}

POST   /api/servers/{id}/test
  Response:
    success: boolean
    error?: string
    capabilities?: object

GET    /api/servers/{id}/logs
  Query:
    lines?: number = 100
    since?: timestamp
  Response:
    logs: Array<LogEntry>

# Environment Variables
PUT    /api/servers/{id}/env/{key}
  Request:
    value: string
  Response: {success: boolean}

# System
GET    /api/health
  Response:
    status: 'healthy' | 'degraded' | 'unhealthy'
    services: object

GET    /api/config/claude-desktop
  Response:
    config: object  # claude_desktop_config.json content

# MCP Protocol Endpoints (FastMCP handles these)
POST   /mcp/initialize
POST   /mcp/initialized
POST   /mcp/tools/list
POST   /mcp/tools/call
POST   /mcp/resources/list
POST   /mcp/resources/read
POST   /mcp/prompts/list
POST   /mcp/prompts/get
POST   /mcp/completion/complete
```

### MCP Protocol Implementation

```python
# Core MCP Router using FastMCP
from fastmcp import FastMCP, Tool, Resource
from typing import Dict, Any, List

class MCPRouterServer:
    def __init__(self, db_service: DatabaseService, container_service: ContainerService):
        self.mcp = FastMCP("MCP Router")
        self.db = db_service
        self.containers = container_service
        self._setup_default_tools()
        
    def _setup_default_tools(self):
        """Register default Python sandbox tool"""
        @self.mcp.tool()
        async def python_sandbox(code: str) -> Dict[str, Any]:
            """Execute Python code in a sandboxed environment with data science libraries"""
            result = await self.containers.execute_in_sandbox(
                runtime="python",
                code=code,
                libraries=["pandas", "numpy", "scipy", "matplotlib", "seaborn"]
            )
            return {
                "output": result.stdout,
                "error": result.stderr,
                "exit_code": result.exit_code
            }
    
    async def refresh_tools(self):
        """Dynamically load tools from all active servers"""
        servers = await self.db.get_active_servers()
        
        for server in servers:
            # Create a dynamic tool that proxies to the containerized server
            tool_func = self._create_proxy_tool(server)
            self.mcp.tool(name=f"{server.name}_tool")(tool_func)
    
    def _create_proxy_tool(self, server: MCPServer):
        async def proxy_tool(**kwargs) -> Any:
            # Spawn container for this server
            container = await self.containers.spawn_container(
                server_id=server.id,
                runtime_type=server.runtime_type,
                env_vars=server.get_env_dict()
            )
            
            try:
                # Forward the tool call to the container
                result = await container.call_tool(kwargs)
                return result
            finally:
                # Clean up container after use
                await container.cleanup()
        
        return proxy_tool
```

## Container Management Strategy

### Runtime Detection and Execution

```python
class ContainerRuntimeDetector:
    """Detects appropriate runtime from GitHub repository"""
    
    async def detect_runtime(self, repo_files: List[str]) -> RuntimeInfo:
        if "package.json" in repo_files:
            return RuntimeInfo(
                type="npx",
                install_command="npm install",
                start_command="npx -y {package_name}"
            )
        elif "pyproject.toml" in repo_files or "setup.py" in repo_files:
            return RuntimeInfo(
                type="uvx",
                install_command="pip install -e .",
                start_command="uvx {package_name}"
            )
        elif "Dockerfile" in repo_files:
            return RuntimeInfo(
                type="docker",
                install_command="docker build -t {name} .",
                start_command="docker run --rm -i {name}"
            )
        else:
            # Fallback to analyzing file extensions
            # ...

class ContainerOrchestrator:
    """Manages container lifecycle using llm-sandbox"""
    
    def __init__(self, config: ContainerConfig):
        self.sandbox_manager = SandboxManager(config)
        self.active_containers: Dict[str, Container] = {}
        
    async def spawn_container(
        self, 
        server_id: str,
        runtime_type: str,
        env_vars: Dict[str, str]
    ) -> Container:
        """Spawn a fresh container for the MCP server"""
        
        # Use llm-sandbox to create appropriate container
        if runtime_type == "npx":
            sandbox = NodejsSandbox(
                max_execution_time=300,
                memory_limit="512m",
                env_vars=env_vars
            )
        elif runtime_type == "uvx":
            sandbox = PythonSandbox(
                max_execution_time=300,
                memory_limit="512m",
                env_vars=env_vars
            )
        elif runtime_type == "docker":
            sandbox = DockerSandbox(
                image=f"mcp-{server_id}",
                max_execution_time=300,
                memory_limit="512m",
                env_vars=env_vars
            )
        
        container = await sandbox.start()
        self.active_containers[container.id] = container
        
        return container
```

## Claude Integration for Repository Analysis

```python
from anthropic import AsyncAnthropic
import base64

class ClaudeRepositoryAnalyzer:
    def __init__(self, api_key: str):
        self.client = AsyncAnthropic(api_key=api_key)
        
    async def analyze_repository(self, github_url: str) -> ServerConfiguration:
        """Use Claude to analyze repository and generate configuration"""
        
        # Fetch repository content
        repo_content = await self._fetch_repo_content(github_url)
        
        # Prepare context for Claude
        context = f"""
        Analyze this GitHub repository for MCP server setup:
        
        Repository: {github_url}
        
        README.md:
        {repo_content.readme}
        
        Package files:
        {repo_content.package_files}
        
        Please determine:
        1. The appropriate runtime (npx for Node.js, uvx for Python, docker if Dockerfile exists)
        2. Installation commands needed
        3. The command to start the MCP server
        4. Required environment variables (look for mentions of API keys, tokens, etc.)
        5. What tools/capabilities this MCP server provides
        6. A brief description of what this server does
        """
        
        response = await self.client.messages.create(
            model="claude-3-sonnet-20240229",
            max_tokens=1500,
            temperature=0,
            system="You are an expert at analyzing MCP (Model Context Protocol) servers. Extract configuration details accurately.",
            messages=[{
                "role": "user",
                "content": context
            }]
        )
        
        # Parse Claude's response into structured data
        config = self._parse_claude_response(response.content)
        
        return ServerConfiguration(
            name=self._extract_name_from_url(github_url),
            github_url=github_url,
            runtime_type=config['runtime'],
            install_command=config['install_command'],
            start_command=config['start_command'],
            env_variables=config['env_variables'],
            description=config['description'],
            capabilities=config['capabilities']
        )
    
    def _parse_claude_response(self, content: str) -> Dict[str, Any]:
        """Parse Claude's response into structured configuration"""
        # Use regex or structured parsing to extract:
        # - Runtime type
        # - Commands
        # - Environment variables with descriptions
        # - Tool capabilities
        # ...
```

## Web UI Implementation

### Flask Application Structure

```python
# Main Flask application with blueprints
from flask import Flask, render_template, request, redirect, url_for, flash
from flask_wtf import FlaskForm
from wtforms import StringField, SelectField, FieldList, FormField
from wtforms.validators import DataRequired, URL

def create_app():
    app = Flask(__name__)
    app.config.from_object(Config)
    
    # Initialize extensions
    db.init_app(app)
    csrf = CSRFProtect(app)
    
    # Register blueprints
    app.register_blueprint(main_bp)
    app.register_blueprint(servers_bp, url_prefix='/servers')
    app.register_blueprint(mcp_bp, url_prefix='/mcp')
    
    return app

# Server management forms
class EnvVarForm(FlaskForm):
    key = StringField('Key', validators=[DataRequired()])
    value = StringField('Value')
    description = StringField('Description')

class ServerForm(FlaskForm):
    name = StringField('Name', validators=[DataRequired()])
    github_url = StringField('GitHub URL', validators=[DataRequired(), URL()])
    runtime_type = SelectField('Runtime', choices=[
        ('npx', 'Node.js (npx)'),
        ('uvx', 'Python (uvx)'),
        ('docker', 'Docker')
    ])
    env_vars = FieldList(FormField(EnvVarForm), min_entries=0)

# Server routes
@servers_bp.route('/add', methods=['GET', 'POST'])
def add_server():
    """Add new server with GitHub analysis"""
    form = ServerForm()
    analysis_result = None
    
    if request.method == 'POST':
        if 'analyze' in request.form:
            # Analyze GitHub repository using Claude
            github_url = form.github_url.data
            if github_url:
                analyzer = ClaudeAnalyzer()
                analysis_result = analyzer.analyze_repository(github_url)
                
                # Pre-populate form with analysis results
                form.name.data = analysis_result.name
                form.runtime_type.data = analysis_result.runtime_type
                
                # Add environment variables
                for env_var in analysis_result.env_variables:
                    env_form = EnvVarForm()
                    env_form.key.data = env_var.key
                    env_form.description.data = env_var.description
                    form.env_vars.append_entry(env_form)
                    
        elif form.validate_on_submit():
            # Create and save server
            server = MCPServer(
                name=form.name.data,
                github_url=form.github_url.data,
                runtime_type=form.runtime_type.data
            )
            
            # Add environment variables
            for env_form in form.env_vars:
                if env_form.key.data:
                    server.add_env_var(
                        key=env_form.key.data,
                        value=env_form.value.data,
                        description=env_form.description.data
                    )
            
            db.session.add(server)
            db.session.commit()
            
            flash(f'Server "{server.name}" added successfully!', 'success')
            return redirect(url_for('servers.list_servers'))
    
    return render_template('servers/add.html', 
                         form=form, 
                         analysis_result=analysis_result)
```

### Templates with Progressive Enhancement

#### Base Template (templates/base.html)

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{% block title %}MCP Router{% endblock %}</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/htmx.org@1.9.10"></script>
    <meta name="csrf-token" content="{{ csrf_token() }}">
</head>
<body class="bg-gray-50">
    <nav class="bg-white shadow">
        <div class="max-w-7xl mx-auto px-4">
            <div class="flex justify-between h-16">
                <div class="flex items-center">
                    <h1 class="text-xl font-semibold">MCP Router</h1>
                </div>
                <div class="flex items-center space-x-4">
                    <a href="{{ url_for('main.dashboard') }}" 
                       class="text-gray-600 hover:text-gray-900">Dashboard</a>
                    <a href="{{ url_for('servers.list_servers') }}" 
                       class="text-gray-600 hover:text-gray-900">Servers</a>
                </div>
            </div>
        </div>
    </nav>

    <main class="max-w-7xl mx-auto py-6 px-4">
        {% with messages = get_flashed_messages(with_categories=true) %}
            {% if messages %}
                <div class="mb-4">
                    {% for category, message in messages %}
                        <div class="alert p-4 mb-2 rounded-md
                                   {% if category == 'success' %}bg-green-100 text-green-700
                                   {% elif category == 'error' %}bg-red-100 text-red-700
                                   {% else %}bg-blue-100 text-blue-700{% endif %}">
                            {{ message }}
                        </div>
                    {% endfor %}
                </div>
            {% endif %}
        {% endwith %}

        {% block content %}{% endblock %}
    </main>

    <script>
        // Configure htmx for dynamic updates
        document.body.addEventListener('htmx:configRequest', function(evt) {
            evt.detail.headers['X-CSRFToken'] = 
                document.querySelector('meta[name="csrf-token"]').getAttribute('content');
        });
    </script>
</body>
</html>
```

#### Server List (templates/servers/list.html)

```html
{% extends "base.html" %}

{% block title %}Servers - MCP Router{% endblock %}

{% block content %}
<div class="flex justify-between items-center mb-6">
    <h2 class="text-2xl font-bold">MCP Servers</h2>
    <a href="{{ url_for('servers.add_server') }}" 
       class="bg-blue-500 text-white px-4 py-2 rounded-md hover:bg-blue-600">
        Add Server
    </a>
</div>

<div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
    {% for server in servers %}
        <div class="bg-white rounded-lg shadow p-6">
            <div class="flex items-center justify-between mb-4">
                <h3 class="text-lg font-semibold">{{ server.name }}</h3>
                <span class="px-2 py-1 rounded-full text-xs font-medium
                           {% if server.is_healthy %}bg-green-100 text-green-800
                           {% else %}bg-red-100 text-red-800{% endif %}">
                    {% if server.is_healthy %}Healthy{% else %}Unhealthy{% endif %}
                </span>
            </div>
            
            <p class="text-gray-600 text-sm mb-4">{{ server.description or 'No description' }}</p>
            
            <div class="flex items-center justify-between text-sm">
                <span class="px-2 py-1 bg-gray-100 rounded">{{ server.runtime_type }}</span>
                <div class="space-x-2">
                    <button hx-get="{{ url_for('servers.test_connection', server_id=server.id) }}"
                            hx-target="#test-result-{{ server.id }}"
                            class="text-blue-500 hover:text-blue-600">Test</button>
                    <a href="{{ url_for('servers.detail', server_id=server.id) }}"
                       class="text-blue-500 hover:text-blue-600">View</a>
                </div>
            </div>
            
            <div id="test-result-{{ server.id }}" class="mt-2"></div>
        </div>
    {% endfor %}
</div>

{% if not servers %}
    <div class="text-center py-12">
        <p class="text-gray-500 text-lg">No servers configured yet.</p>
        <a href="{{ url_for('servers.add_server') }}" 
           class="text-blue-500 hover:text-blue-600">Add your first server →</a>
    </div>
{% endif %}
{% endblock %}
```

#### Add Server Form (templates/servers/add.html)

```html
{% extends "base.html" %}

{% block content %}
<div class="max-w-2xl mx-auto">
    <h2 class="text-2xl font-bold mb-6">Add MCP Server</h2>
    
    <form method="POST" class="space-y-6">
        {{ form.hidden_tag() }}
        
        <!-- GitHub URL Analysis -->
        <div class="bg-white p-6 rounded-lg shadow">
            <h3 class="text-lg font-medium mb-4">Repository Analysis</h3>
            
            <div class="mb-4">
                {{ form.github_url.label(class="block text-sm font-medium mb-2") }}
                {{ form.github_url(class="w-full p-2 border rounded-md") }}
            </div>
            
            <button type="submit" name="analyze" 
                    class="bg-blue-500 text-white px-4 py-2 rounded-md hover:bg-blue-600">
                Analyze Repository
            </button>
        </div>
        
        {% if analysis_result %}
        <!-- Analysis Results Display -->
        <div class="bg-green-50 p-6 rounded-lg border border-green-200">
            <h4 class="text-lg font-medium text-green-800 mb-2">Analysis Complete!</h4>
            <p class="text-green-700">{{ analysis_result.description }}</p>
            
            <div class="mt-4 flex space-x-2">
                <span class="px-2 py-1 bg-green-100 text-green-700 rounded text-sm">
                    {{ analysis_result.runtime_type }}
                </span>
                <span class="px-2 py-1 bg-blue-100 text-blue-700 rounded text-sm">
                    {{ analysis_result.transport_type }}
                </span>
            </div>
        </div>
        
        <!-- Server Configuration Form -->
        <div class="bg-white p-6 rounded-lg shadow">
            <h3 class="text-lg font-medium mb-4">Server Configuration</h3>
            
            <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                <div>
                    {{ form.name.label(class="block text-sm font-medium mb-2") }}
                    {{ form.name(class="w-full p-2 border rounded-md") }}
                </div>
                <div>
                    {{ form.runtime_type.label(class="block text-sm font-medium mb-2") }}
                    {{ form.runtime_type(class="w-full p-2 border rounded-md") }}
                </div>
            </div>
            
            <!-- Environment Variables Section -->
            {% if form.env_vars %}
            <div class="mt-6">
                <h4 class="text-md font-medium mb-3">Environment Variables</h4>
                {% for env_form in form.env_vars %}
                <div class="grid grid-cols-1 md:grid-cols-3 gap-2 mb-2">
                    {{ env_form.key(class="p-2 border rounded-md", placeholder="Key") }}
                    {{ env_form.value(class="p-2 border rounded-md", placeholder="Value") }}
                    {{ env_form.description(class="p-2 border rounded-md", readonly=true) }}
                </div>
                {% endfor %}
            </div>
            {% endif %}
            
            <div class="mt-6 flex justify-end space-x-3">
                <a href="{{ url_for('servers.list_servers') }}" 
                   class="px-4 py-2 border rounded-md hover:bg-gray-50">Cancel</a>
                <button type="submit" 
                        class="bg-green-500 text-white px-4 py-2 rounded-md hover:bg-green-600">
                    Add Server
                </button>
            </div>
        </div>
        {% endif %}
    </form>
</div>
{% endblock %}
```

## Transport Layer Implementation

### Multi-Transport Support

```python
from abc import ABC, abstractmethod
from typing import Any, AsyncIterator
import asyncio
import httpx

class TransportAdapter(ABC):
    """Base class for MCP transport adapters"""
    
    @abstractmethod
    async def connect(self) -> None:
        pass
    
    @abstractmethod
    async def send_request(self, method: str, params: Any) -> Any:
        pass
    
    @abstractmethod
    async def close(self) -> None:
        pass

class StdioTransportAdapter(TransportAdapter):
    """Handles stdio-based MCP communication"""
    
    def __init__(self, process: asyncio.subprocess.Process):
        self.process = process
        self.reader = asyncio.StreamReader()
        self.writer = process.stdin
        
    async def connect(self) -> None:
        # Set up async reading from stdout
        asyncio.create_task(self._read_output())
        
    async def send_request(self, method: str, params: Any) -> Any:
        request = {
            "jsonrpc": "2.0",
            "method": method,
            "params": params,
            "id": str(uuid.uuid4())
        }
        
        # Write to stdin
        self.writer.write(json.dumps(request).encode() + b'\n')
        await self.writer.drain()
        
        # Wait for response
        response = await self._wait_for_response(request["id"])
        return response

class SSETransportAdapter(TransportAdapter):
    """Handles Server-Sent Events MCP communication"""
    
    def __init__(self, url: str, headers: Dict[str, str] = None):
        self.url = url
        self.headers = headers or {}
        self.client = httpx.AsyncClient()
        
    async def connect(self) -> None:
        # Establish SSE connection
        self.event_source = await self.client.stream(
            'GET', 
            f"{self.url}/sse",
            headers=self.headers
        )
        
    async def send_request(self, method: str, params: Any) -> Any:
        response = await self.client.post(
            f"{self.url}/mcp/{method}",
            json=params,
            headers=self.headers
        )
        return response.json()

class HTTPTransportAdapter(TransportAdapter):
    """Handles HTTP-based MCP communication"""
    
    def __init__(self, url: str, headers: Dict[str, str] = None):
        self.url = url
        self.headers = headers or {}
        self.client = httpx.AsyncClient()
        
    async def send_request(self, method: str, params: Any) -> Any:
        response = await self.client.post(
            f"{self.url}/mcp/{method}",
            json={
                "jsonrpc": "2.0",
                "method": method,
                "params": params,
                "id": str(uuid.uuid4())
            },
            headers=self.headers
        )
        return response.json()

class TransportManager:
    """Manages transport adapters for different MCP servers"""
    
    def __init__(self):
        self.adapters: Dict[str, TransportAdapter] = {}
        
    async def create_adapter(
        self, 
        server: MCPServer, 
        container: Container
    ) -> TransportAdapter:
        """Create appropriate transport adapter for server"""
        
        if server.transport_type == "stdio":
            # Get the process from container
            process = await container.get_process()
            adapter = StdioTransportAdapter(process)
            
        elif server.transport_type == "sse":
            # Get the HTTP endpoint from container
            endpoint = await container.get_endpoint()
            adapter = SSETransportAdapter(
                url=endpoint,
                headers={"Authorization": f"Bearer {container.auth_token}"}
            )
            
        elif server.transport_type == "http":
            endpoint = await container.get_endpoint()
            adapter = HTTPTransportAdapter(
                url=endpoint,
                headers={"Authorization": f"Bearer {container.auth_token}"}
            )
            
        await adapter.connect()
        self.adapters[server.id] = adapter
        
        return adapter
```

## Claude Desktop Integration

### Configuration Generator

```python
class ClaudeDesktopConfigGenerator:
    """Generates claude_desktop_config.json for local integration"""
    
    def generate_config(self, router_config: RouterConfig) -> Dict[str, Any]:
        if router_config.mode == "local":
            # Local stdio mode for Claude Desktop
            return {
                "mcpServers": {
                    "mcp-router": {
                        "command": "python",
                        "args": [
                            "-m",
                            "mcp_router",
                            "--mode",
                            "stdio"
                        ],
                        "env": {
                            "MCP_ROUTER_DB": str(router_config.db_path),
                            "MCP_ROUTER_CACHE": str(router_config.cache_path)
                        }
                    }
                }
            }
        else:
            # Remote HTTP mode
            return {
                "mcpServers": {
                    "mcp-router": {
                        "url": router_config.remote_url,
                        "transport": "sse",
                        "headers": {
                            "Authorization": f"Bearer {router_config.api_key}"
                        }
                    }
                }
            }
    
    def save_config(self, config: Dict[str, Any], path: Path = None):
        """Save config to Claude Desktop configuration directory"""
        if path is None:
            # Default Claude Desktop config location
            if sys.platform == "darwin":  # macOS
                path = Path.home() / "Library/Application Support/Claude/claude_desktop_config.json"
            elif sys.platform == "win32":  # Windows
                path = Path.home() / "AppData/Roaming/Claude/claude_desktop_config.json"
            else:  # Linux
                path = Path.home() / ".config/claude/claude_desktop_config.json"
        
        path.parent.mkdir(parents=True, exist_ok=True)
        
        # Merge with existing config if present
        existing = {}
        if path.exists():
            existing = json.loads(path.read_text())
        
        existing.update(config)
        path.write_text(json.dumps(existing, indent=2))
```

## Default Python Sandbox Implementation

```python
class PythonSandboxTool:
    """Built-in Python sandbox with data science libraries"""
    
    DEFAULT_IMPORTS = """
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import scipy
import sklearn
from io import StringIO
import json
import requests
import datetime
"""
    
    def __init__(self, container_manager: ContainerOrchestrator):
        self.container_manager = container_manager
        self.sandbox_image = "mcp-router/python-sandbox:latest"
        
    async def execute_code(self, code: str) -> Dict[str, Any]:
        """Execute Python code in sandboxed environment"""
        
        # Prepend default imports
        full_code = self.DEFAULT_IMPORTS + "\n\n" + code
        
        # Create temporary container
        container = await self.container_manager.spawn_container(
            server_id="python-sandbox",
            runtime_type="docker",
            env_vars={
                "PYTHONUNBUFFERED": "1",
                "MPLBACKEND": "Agg"  # Non-interactive matplotlib backend
            }
        )
        
        try:
            # Execute code
            result = await container.execute(
                command=["python", "-c", full_code],
                timeout=30
            )
            
            # Capture any generated plots
            plots = await self._extract_plots(container)
            
            return {
                "output": result.stdout,
                "error": result.stderr,
                "exit_code": result.exit_code,
                "plots": plots
            }
            
        finally:
            await container.cleanup()
    
    async def _extract_plots(self, container: Container) -> List[str]:
        """Extract matplotlib plots as base64 images"""
        plots = []
        
        # Check for saved plots in container
        plot_files = await container.list_files("/tmp/plots/")
        
        for file in plot_files:
            if file.endswith(('.png', '.jpg', '.svg')):
                content = await container.read_file(file)
                plots.append({
                    "filename": file,
                    "data": base64.b64encode(content).decode()
                })
        
        return plots
```

## Monitoring and Observability

```python
from prometheus_client import Counter, Histogram, Gauge, Info
import structlog

# Metrics
mcp_requests_total = Counter(
    'mcp_requests_total',
    'Total MCP requests',
    ['server', 'method', 'status']
)

mcp_request_duration = Histogram(
    'mcp_request_duration_seconds',
    'MCP request duration',
    ['server', 'method']
)

active_containers = Gauge(
    'mcp_active_containers',
    'Number of active containers',
    ['runtime_type']
)

server_info = Info(
    'mcp_server_info',
    'Information about MCP servers'
)

# Structured logging
logger = structlog.get_logger()

class MetricsMiddleware:
    """FastAPI middleware for metrics collection"""
    
    async def __call__(self, request: Request, call_next):
        start_time = time.time()
        
        # Extract metadata
        path = request.url.path
        method = request.method
        
        # Log request
        logger.info(
            "http_request_started",
            path=path,
            method=method,
            client_ip=request.client.host
        )
        
        try:
            response = await call_next(request)
            
            # Record metrics
            duration = time.time() - start_time
            
            logger.info(
                "http_request_completed",
                path=path,
                method=method,
                status_code=response.status_code,
                duration=duration
            )
            
            return response
            
        except Exception as e:
            logger.error(
                "http_request_failed",
                path=path,
                method=method,
                error=str(e),
                error_type=type(e).__name__
            )
            raise
```

## Security Implementation

```python
from fastapi import Security, HTTPException, status
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
import jwt

class SecurityConfig:
    """Security configuration and utilities"""
    
    def __init__(self, settings: Settings):
        self.settings = settings
        self.bearer_scheme = HTTPBearer()
        
    async def verify_token(
        self, 
        credentials: HTTPAuthorizationCredentials = Security(HTTPBearer())
    ) -> Dict[str, Any]:
        """Verify JWT token for API access"""
        
        token = credentials.credentials
        
        try:
            payload = jwt.decode(
                token,
                self.settings.jwt_secret,
                algorithms=["HS256"]
            )
            
            # Verify token hasn't expired
            if payload.get("exp", 0) < time.time():
                raise HTTPException(
                    status_code=status.HTTP_401_UNAUTHORIZED,
                    detail="Token has expired"
                )
            
            return payload
            
        except jwt.InvalidTokenError:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Invalid authentication token"
            )
    
    def generate_api_key(self, user_id: str) -> str:
        """Generate API key for remote access"""
        
        payload = {
            "sub": user_id,
            "iat": int(time.time()),
            "exp": int(time.time()) + 86400 * 365,  # 1 year
            "type": "api_key"
        }
        
        return jwt.encode(payload, self.settings.jwt_secret, algorithm="HS256")

class ContainerSecurityPolicy:
    """Security policies for containers"""
    
    @staticmethod
    def get_docker_security_opts() -> List[str]:
        return [
            "--cap-drop=ALL",
            "--cap-add=NET_BIND_SERVICE",
            "--read-only",
            "--security-opt=no-new-privileges:true",
            "--pids-limit=100",
            "--memory=512m",
            "--cpus=1.0"
        ]
    
    @staticmethod
    def get_seccomp_profile() -> Dict[str, Any]:
        """Restrictive seccomp profile for containers"""
        return {
            "defaultAction": "SCMP_ACT_ERRNO",
            "architectures": ["SCMP_ARCH_X86_64"],
            "syscalls": [
                {
                    "names": [
                        "read", "write", "close", "stat", "fstat",
                        "lstat", "poll", "lseek", "mmap", "mprotect",
                        "munmap", "brk", "rt_sigaction", "rt_sigprocmask",
                        "rt_sigreturn", "ioctl", "pread64", "pwrite64",
                        "readv", "writev", "access", "pipe", "select"
                        # ... minimal syscalls needed
                    ],
                    "action": "SCMP_ACT_ALLOW"
                }
            ]
        }
```

## Testing Strategy

### Unit Tests

```python
# tests/test_router.py
import pytest
from unittest.mock import Mock, AsyncMock
from mcp_router.core import MCPRouterServer

@pytest.fixture
def mock_db_service():
    service = Mock()
    service.get_active_servers = AsyncMock(return_value=[
        MCPServer(
            id="test-1",
            name="test-server",
            runtime_type="npx",
            transport_type="stdio"
        )
    ])
    return service

@pytest.fixture
def mock_container_service():
    service = Mock()
    service.spawn_container = AsyncMock()
    return service

@pytest.mark.asyncio
async def test_router_initialization(mock_db_service, mock_container_service):
    """Test MCP router initializes correctly"""
    router = MCPRouterServer(mock_db_service, mock_container_service)
    
    # Verify default tools are registered
    tools = await router.mcp.list_tools()
    assert any(tool.name == "python_sandbox" for tool in tools)

@pytest.mark.asyncio
async def test_proxy_tool_creation(mock_db_service, mock_container_service):
    """Test dynamic proxy tool creation"""
    router = MCPRouterServer(mock_db_service, mock_container_service)
    
    # Refresh tools from database
    await router.refresh_tools()
    
    # Verify proxy tool was created
    tools = await router.mcp.list_tools()
    assert any(tool.name == "test-server_tool" for tool in tools)

# tests/test_container_manager.py
@pytest.mark.asyncio
async def test_container_spawn_and_cleanup():
    """Test container lifecycle management"""
    manager = ContainerOrchestrator(ContainerConfig())
    
    # Spawn container
    container = await manager.spawn_container(
        server_id="test",
        runtime_type="python",
        env_vars={"TEST": "value"}
    )
    
    assert container.id in manager.active_containers
    
    # Cleanup
    await container.cleanup()
    
    assert container.id not in manager.active_containers
```

### Integration Tests

```python
# tests/integration/test_e2e_flow.py
import httpx
import asyncio
from testcontainers.compose import DockerCompose

@pytest.mark.integration
async def test_complete_server_addition_flow():
    """Test adding and using an MCP server end-to-end"""
    
    async with httpx.AsyncClient(base_url="http://localhost:8080") as client:
        # 1. Analyze GitHub repository
        analysis = await client.post("/api/servers/analyze", json={
            "github_url": "https://github.com/example/test-mcp-server"
        })
        assert analysis.status_code == 200
        
        config = analysis.json()
        
        # 2. Create server with configuration
        server_response = await client.post("/api/servers", json={
            **config,
            "env_variables": [
                {"key": "API_KEY", "value": "test-key"}
            ]
        })
        assert server_response.status_code == 201
        
        server = server_response.json()
        
        # 3. Test server connection
        test_response = await client.post(f"/api/servers/{server['id']}/test")
        assert test_response.status_code == 200
        assert test_response.json()["success"]
        
        # 4. Use server through MCP protocol
        mcp_response = await client.post("/mcp/tools/list")
        tools = mcp_response.json()["tools"]
        
        # Verify our server's tools are available
        server_tools = [t for t in tools if t["name"].startswith(server["name"])]
        assert len(server_tools) > 0
```

## Deployment Configuration

### Docker Compose Setup

```yaml
# docker-compose.yml
version: '3.8'

services:
  mcp-router:
    build: .
    ports:
      - "8080:8080"
    environment:
      - DATABASE_URL=sqlite:///data/mcp_router.db
      - E2B_API_KEY=${E2B_API_KEY}
      - ANTHROPIC_API_KEY=${ANTHROPIC_API_KEY}
      - GITHUB_TOKEN=${GITHUB_TOKEN}
    volumes:
      - ./data:/data
      - /var/run/docker.sock:/var/run/docker.sock  # For Docker-in-Docker
    depends_on:
      - redis
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8080/api/health"]
      interval: 30s
      timeout: 10s
      retries: 3

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    volumes:
      - redis-data:/data

  prometheus:
    image: prom/prometheus:latest
    ports:
      - "9090:9090"
    volumes:
      - ./prometheus.yml:/etc/prometheus/prometheus.yml
      - prometheus-data:/prometheus

  grafana:
    image: grafana/grafana:latest
    ports:
      - "3000:3000"
    environment:
      - GF_SECURITY_ADMIN_PASSWORD=admin
    volumes:
      - grafana-data:/var/lib/grafana
      - ./grafana/dashboards:/etc/grafana/provisioning/dashboards
      - ./grafana/datasources:/etc/grafana/provisioning/datasources

volumes:
  redis-data:
  prometheus-data:
  grafana-data:

# Dockerfile
FROM python:3.11-slim

WORKDIR /app

# Install system dependencies
RUN apt-get update && apt-get install -y \
    curl \
    git \
    docker.io \
    && rm -rf /var/lib/apt/lists/*

# Install Python dependencies
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# Copy application
COPY . .

# Create non-root user
RUN useradd -m -u 1000 mcp && chown -R mcp:mcp /app
USER mcp

# Expose ports
EXPOSE 8080

# Run application
CMD ["python", "run.py"]
```

## Sprint-by-Sprint Detailed Plan

### Sprint 1: Foundation & Web UI (Week 1)

**Day 1-2: Project Setup & Database**
- Initialize Python project with Flask structure
- Set up SQLAlchemy models and database migrations
- Create Pydantic schemas for validation
- Implement basic Flask application factory
- Set up pytest and testing infrastructure

**Day 3-4: Web UI Foundation**
- Create Flask templates with TailwindCSS
- Implement server list view with Jinja2
- Build add server form with WTForms
- Create base template and layout
- Add htmx for dynamic interactions

**Day 5: Integration**
- Implement server CRUD routes
- Add form validation and error handling
- Create flash messaging system
- Basic session management
- End-to-end testing

**Deliverables:**
- Working web UI for server management
- Database persistence for configurations
- Server-side rendered interface

### Sprint 2: Container Integration & MCP Core (Week 2)

**Day 1-2: Container Management**
- Integrate llm-sandbox library
- Implement runtime detection logic
- Create container lifecycle manager
- Add resource limits and security policies

**Day 3-4: MCP Router Implementation**
- Set up FastMCP server structure
- Implement dynamic tool registration
- Create proxy tool mechanism
- Add default Python sandbox tool

**Day 5: Transport Layer**
- Implement stdio transport adapter
- Add basic HTTP transport support
- Create transport manager
- Integration testing with containers

**Deliverables:**
- Container spawning for all runtime types
- Basic MCP routing functionality
- Python sandbox tool working

### Sprint 3: Claude Integration & Advanced Features (Week 3)

**Day 1-2: Claude Repository Analysis**
- Integrate Anthropic SDK
- Implement repository fetching from GitHub
- Create Claude prompt templates
- Parse analysis results into configurations

**Day 3-4: Transport Completion**
- Implement SSE transport adapter
- Add transport auto-detection
- Create connection pooling
- Implement circuit breaker pattern

**Day 5: Claude Desktop Integration**
- Create configuration generator
- Add local/remote mode support
- Implement setup instructions UI
- Test with Claude Desktop

**Deliverables:**
- Automated repository analysis
- All transport types supported
- Claude Desktop integration working

### Sprint 4: Production Features & Polish (Week 4)

**Day 1-2: Security & Monitoring**
- Implement JWT authentication
- Add API key generation
- Set up Prometheus metrics
- Create Grafana dashboards

**Day 3-4: Testing & Documentation**
- Comprehensive integration tests
- Load testing with multiple containers
- API documentation with OpenAPI
- User guide and setup instructions

**Day 5: Deployment & Optimization**
- Docker image optimization
- Production deployment scripts
- Performance tuning
- Final bug fixes

**Deliverables:**
- Production-ready application
- Complete documentation
- Monitoring and observability
- Deployment packages

## Configuration Files

### Settings Configuration

```python
# mcp_router/config/settings.py
from pydantic import BaseSettings, Field
from typing import Optional, Literal
from pathlib import Path

class Settings(BaseSettings):
    # Application
    app_name: str = "MCP Router"
    debug: bool = Field(False, env="DEBUG")
    host: str = Field("0.0.0.0", env="HOST")
    port: int = Field(8080, env="PORT")
    
    # Database
    database_url: str = Field(
        "sqlite:///./data/mcp_router.db",
        env="DATABASE_URL"
    )
    
    # Security
    secret_key: str = Field(..., env="SECRET_KEY")
    jwt_algorithm: str = "HS256"
    jwt_expiration: int = 86400  # 24 hours
    
    # External Services
    anthropic_api_key: str = Field(..., env="ANTHROPIC_API_KEY")
    github_token: Optional[str] = Field(None, env="GITHUB_TOKEN")
    e2b_api_key: Optional[str] = Field(None, env="E2B_API_KEY")
    
    # Container Configuration
    container_backend: Literal["docker", "e2b"] = Field(
        "docker",
        env="CONTAINER_BACKEND"
    )
    max_concurrent_containers: int = Field(10, env="MAX_CONTAINERS")
    container_timeout: int = Field(300, env="CONTAINER_TIMEOUT")
    container_memory_limit: str = Field("512m", env="CONTAINER_MEMORY")
    container_cpu_limit: float = Field(1.0, env="CONTAINER_CPU")
    
    # MCP Configuration
    mcp_mode: Literal["local", "remote"] = Field("local", env="MCP_MODE")
    mcp_remote_url: Optional[str] = Field(None, env="MCP_REMOTE_URL")
    
    # Cache
    redis_url: Optional[str] = Field(None, env="REDIS_URL")
    cache_ttl: int = Field(3600, env="CACHE_TTL")
    
    # Monitoring
    enable_metrics: bool = Field(True, env="ENABLE_METRICS")
    metrics_port: int = Field(9090, env="METRICS_PORT")
    
    # Paths
    data_dir: Path = Field(Path("./data"), env="DATA_DIR")
    log_dir: Path = Field(Path("./logs"), env="LOG_DIR")
    
    class Config:
        env_file = ".env"
        case_sensitive = False

    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        # Create directories
        self.data_dir.mkdir(exist_ok=True)
        self.log_dir.mkdir(exist_ok=True)
```

### Requirements File

```txt
# requirements.txt
# Core Flask Application
flask==2.3.3
flask-sqlalchemy==3.0.5
flask-wtf==1.2.1
flask-login==0.6.3
wtforms==3.1.0
pydantic==2.5.0
python-dotenv==1.0.0

# MCP
fastmcp==2.0.0

# Database
sqlalchemy==2.0.23
alembic==1.12.1

# Container Management
llm-sandbox==0.1.0
docker==6.1.3

# External Services
anthropic==0.8.0
httpx==0.25.1
PyGithub==2.1.1

# Authentication & Security
python-jose[cryptography]==3.3.0
passlib[bcrypt]==1.7.4

# Monitoring
prometheus-client==0.19.0
structlog==23.2.0

# Testing
pytest==7.4.3
pytest-flask==1.3.0
pytest-cov==4.1.0
testcontainers==3.7.1

# Utilities
tenacity==8.2.3
cachetools==5.3.2
```

## Project Structure

```
mcp-router/
├── mcp_router/
│   ├── __init__.py
│   ├── app.py                    # Flask application factory
│   ├── routes/
│   │   ├── __init__.py
│   │   ├── main.py              # Dashboard & server list routes
│   │   ├── servers.py           # Server CRUD operations
│   │   ├── api.py               # JSON API for htmx
│   │   └── mcp.py               # MCP protocol endpoints
│   ├── templates/
│   │   ├── base.html            # Base template with TailwindCSS
│   │   ├── dashboard.html       # Main dashboard
│   │   ├── servers/
│   │   │   ├── list.html        # Server list view
│   │   │   ├── add.html         # Add server form
│   │   │   ├── edit.html        # Edit server form
│   │   │   └── detail.html      # Server details & logs
│   │   └── components/
│   │       ├── server_card.html # Server status card
│   │       ├── env_form.html    # Environment variables form
│   │       └── test_result.html # Connection test result
│   ├── static/
│   │   ├── css/
│   │   │   └── app.css          # Custom styles
│   │   ├── js/
│   │   │   └── app.js           # Minimal JavaScript + htmx
│   │   └── favicon.ico
│   ├── forms/
│   │   ├── __init__.py
│   │   ├── server_forms.py      # WTForms for server management
│   │   └── validators.py        # Custom form validators
│   ├── core/
│   │   ├── __init__.py
│   │   ├── router.py            # MCP router implementation
│   │   ├── registry.py          # Server registry
│   │   └── auth.py              # Authentication logic
│   ├── services/
│   │   ├── __init__.py
│   │   ├── claude_analyzer.py   # Claude repository analysis
│   │   ├── github_service.py    # GitHub integration
│   │   ├── container_manager.py # Container orchestration
│   │   └── transport_manager.py # Transport adapters
│   ├── models/
│   │   ├── __init__.py
│   │   ├── database.py          # SQLAlchemy models
│   │   └── schemas.py           # Pydantic schemas
│   ├── config/
│   │   ├── __init__.py
│   │   └── settings.py          # Application settings
│   └── utils/
│       ├── __init__.py
│       ├── logging.py           # Logging configuration
│       └── metrics.py           # Prometheus metrics
├── tests/
│   ├── __init__.py
│   ├── unit/
│   ├── integration/
│   └── fixtures/
├── deployment/
│   ├── docker-compose.yml
│   ├── docker-compose.prod.yml
│   ├── Dockerfile
│   ├── prometheus.yml
│   └── grafana/
├── docs/
│   ├── README.md
│   ├── API.md
│   ├── DEPLOYMENT.md
│   └── USER_GUIDE.md
├── scripts/
│   ├── setup.sh
│   ├── test.sh
│   └── deploy.sh
├── .env.example
├── .gitignore
├── requirements.txt
├── requirements-dev.txt
├── pyproject.toml
├── run.py                       # Application entry point
└── README.md
```

## Summary

This comprehensive plan provides:

1. **Complete feature coverage** - All 9 requirements addressed with implementation details
2. **Simplified architecture** - Single Flask codebase with server-side rendering
3. **Practical sprint planning** - Daily tasks optimized for single developer efficiency
4. **Production readiness** - Security, monitoring, and deployment
5. **Extensive code examples** - Real Flask implementation patterns
6. **Testing strategy** - Unit, integration, and functional tests
7. **Documentation** - User guides and deployment instructions
8. **Configuration management** - Environment-based settings
9. **Container security** - Isolation and resource limits
10. **Monitoring and observability** - Metrics and structured logging

